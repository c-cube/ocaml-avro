
module Sc = Schema

let spf = Printf.sprintf
let aspf = Format.asprintf
let fpf = Format.fprintf
let pstr = Format.pp_print_string

(* taken from containers' CCFormat.string_lines *)
let ptext out s =
  fpf out "@[<v>";
  let i = ref 0 in
  let n = String.length s in
  while !i < n do
    let j =
      try String.index_from s !i '\n' with Not_found -> n in
    if !i>0 then fpf out "@,";
    pstr out (String.sub s !i (j - !i));
    i := j+1;
  done;
  fpf out "@]"

module Code = struct
  type t =
    | Top of string
    | Mod of string * t list

  let to_string (l:t list) : string =
    let rec pp out l =
      List.iteri (fun i s ->
          if i>0 then fpf out "@ @ ";
          match s with
          | Top s -> fpf out "@[%a@]" ptext s
          | Mod (name,l) ->
            Format.fprintf out "@[<v2>module %s = struct@ " name ;
            pp out l;
            Format.fprintf out "@ end@]@ ";
        )
        l;
    in
    Format.asprintf "@[<v>%a@]@." pp l

  let s str : t = Top str
  let sf fmt = Format.kasprintf s fmt

  let mod_ m l : t = Mod (m, l)
end

type state = {
  mutable code: Code.t list;
}

let push (self:state) c : unit = self.code <- c :: self.code

(** Print as a type *)
let rec pp_ty self out ty =
  let recurse = pp_ty self in
  match ty with
  | Sc.Atomic a ->
    let str = match a with
      | Sc.Null -> "unit"
      | Sc.Bool -> "bool"
      | Sc.Int32 -> "int"
      | Sc.Int64 -> "int64"
      | Sc.Float32 | Sc.Float64 -> "float"
      | Sc.String | Sc.Bytes -> "string"
    in
    pstr out str

  | Sc.Array ty ->
    fpf out "@[%a@ array@]" recurse ty

  | Sc.Str_map ty ->
    fpf out "@[%a@ Str_map.t@]" recurse ty

  | _ty ->
    fpf out " Todo (* type: %a *)" Sc.pp ty

(** Print as a toplevel declaration for a type named [name] *)
and gen_decl (self:state) ~name (s:Schema.t) : unit =
  push self (Code.sf "@[<hv2>type %s =@ %a@]" name (pp_ty self) s)

let rec gen_read (self:state) out (ty:Schema.t) : unit =
  let recurse = gen_read self in
  match ty with
  | Sc.Atomic a ->
    let str = match a with
      | Sc.Null -> "()"
      | Sc.Bool -> "Input.read_bool input"
      | Sc.Int32 -> "Input.read_int input"
      | Sc.Int64 -> "Input.read_int64 input"
      | Sc.Float32 -> "Input.read_float32 input"
      | Sc.Float64 -> "Input.read_float64 input"
      | Sc.String | Sc.Bytes -> "Input.read_string input"
    in
    pstr out str

  | Sc.Array ty ->
    fpf out "(@[<v>let len = Input.read_int input in@ ";
    fpf out "@[<2>Array.init len@ \
             (@[fun _ ->@ %a@])@]@])" recurse ty

  | Sc.Str_map ty ->
    fpf out "(@[<v>let len = Input.read_int input in@ ";
    fpf out "@[<2>let arr =@ Array.init len@ \
             (@[fun _ ->@ \
             let k = Input.read_string input in@ \
             let v = %a in@ \
             k, v@]) in@]@ "
      recurse ty;
    fpf out "Array.fold_left (fun m (k,v) -> Str_map.add k v m) Str_map.empty arr@])"

  | _ty ->
    fpf out " assert false (* type: %a *)" Sc.pp ty

and gen_read_top (self:state) ~name ~ty_name (s:Schema.t) : unit =
  push self (Code.sf "@[<hv2>let %s (input:Input.t) : %s =@ %a@]"
               name ty_name (gen_read self) s)

let gen ?(internal=false) (s:Schema.t) : Code.t list =
  let self = {code=[]} in
  push self (Code.sf "(* generated by avro-compiler *)@.");
  if not internal then push self (Code.sf "open Avro@.");
  push self (Code.sf "module Str_map = Map.Make(String)@.");
  gen_decl self ~name:"t" s;
  gen_read_top self ~name:"read" ~ty_name:"t" s;
  List.rev self.code
